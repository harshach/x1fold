#!/usr/bin/env bash

# On-screen keyboard manager for the ThinkPad X1 Fold 16 under Hyprland.
#
# Uses wvkbd with two auto-show mechanisms:
#   1. input-method-v2 protocol: wvkbd auto-shows when apps focus a text
#      input field (GTK, Qt, etc.)
#   2. Hyprland IPC: for terminals (which don't use text-input-v3), the
#      daemon detects terminal window focus and force-shows wvkbd.
#
# When a physical keyboard is connected, wvkbd is killed entirely.
#
# Usage:
#   x1fold-osk toggle      # Manual show/hide toggle
#   x1fold-osk show        # Show the keyboard
#   x1fold-osk hide        # Hide the keyboard
#   x1fold-osk daemon      # Run keyboard presence monitor (for autostart)
#
# Requires: wvkbd, socat

set -euo pipefail

WVKBD_OPTS="${X1FOLD_WVKBD_OPTS:---landscape-layers full --hidden}"
TERMINAL_CLASSES="${X1FOLD_TERMINAL_CLASSES:-Alacritty|kitty|ghostty|com\.mitchellh\.ghostty|foot|org\.wezfurlong\.wezterm}"
KB_STATE_FILE="${XDG_RUNTIME_DIR:-/tmp}/x1fold-kb-present"
OSK_DISMISSED_FILE="${XDG_RUNTIME_DIR:-/tmp}/x1fold-osk-dismissed"

ensure_wvkbd() {
    if ! pgrep -x wvkbd-mobintl >/dev/null 2>&1; then
        # shellcheck disable=SC2086
        wvkbd-mobintl $WVKBD_OPTS &
        disown
        sleep 0.3
    fi
}

osk_show() {
    ensure_wvkbd
    pkill -SIGUSR2 wvkbd-mobintl 2>/dev/null || true
}

osk_hide() {
    pkill -SIGUSR1 wvkbd-mobintl 2>/dev/null || true
    # Mark as manually dismissed so the daemon doesn't re-show
    touch "$OSK_DISMISSED_FILE"
}

osk_toggle() {
    ensure_wvkbd
    pkill -SIGRTMIN wvkbd-mobintl 2>/dev/null || true
    # Mark as dismissed (toggle assumed to be hiding if daemon was showing)
    touch "$OSK_DISMISSED_FILE"
}

has_physical_keyboard() {
    # Check if a real external keyboard (USB or Bluetooth) is present.
    # The X1 Fold has no built-in keyboard, but the PS/2 controller stub
    # ("AT Translated Set 2 keyboard" at isa0060/serio0) is always present.
    # We skip it and only match USB/Bluetooth keyboards.
    local dev_dir name phys
    for dev_dir in /sys/class/input/event*/device; do
        [[ -f "$dev_dir/name" ]] || continue
        name="$(cat "$dev_dir/name" 2>/dev/null || true)"

        # Only consider devices with "keyboard" in the name (case-insensitive)
        [[ "${name,,}" == *keyboard* ]] || continue

        # Skip companion devices (Mouse, Touchpad) — only match actual keyboards
        [[ "${name,,}" == *mouse* || "${name,,}" == *touchpad* ]] && continue

        phys="$(cat "$dev_dir/phys" 2>/dev/null || true)"

        # Skip the PS/2 stub (always present on X1 Fold, not a real keyboard)
        [[ "$phys" == isa0060* ]] && continue

        # Skip virtual/seat devices
        [[ -z "$phys" || "$phys" == *seat* || "$phys" == *input-method* ]] && continue

        # Found a real external keyboard
        return 0
    done
    return 1
}

is_terminal_class() {
    [[ "$1" =~ ^($TERMINAL_CLASSES)$ ]]
}

monitor_keyboard_presence() {
    # Background job: watch udev for keyboard attach/detach and update state file.
    stdbuf -oL udevadm monitor --subsystem-match=input --udev 2>/dev/null | while read -r line; do
        if [[ "$line" =~ (add|remove).*input ]]; then
            sleep 0.5  # let the device settle
            if has_physical_keyboard; then
                touch "$KB_STATE_FILE"
                pkill -x wvkbd-mobintl 2>/dev/null || true
            else
                rm -f "$KB_STATE_FILE"
                ensure_wvkbd
                # If a terminal is already focused, show immediately
                local class
                class="$(hyprctl activewindow -j 2>/dev/null | jq -r '.class // ""' 2>/dev/null)"
                if is_terminal_class "$class"; then
                    osk_show
                fi
            fi
        fi
    done
}

monitor_active_window() {
    # Foreground job: watch Hyprland IPC for window focus changes.
    # Terminals don't implement text-input-v3, so we force-show wvkbd
    # when a terminal is focused. For other apps, we hide and let
    # input-method-v2 auto-show for text fields.
    #
    # Respects manual dismissal: if the user hides via toggle/hide,
    # we don't re-show until the active window changes.
    local socket="${XDG_RUNTIME_DIR}/hypr/${HYPRLAND_INSTANCE_SIGNATURE}/.socket2.sock"
    local prev_class=""

    socat -U - "UNIX-CONNECT:$socket" 2>/dev/null | while read -r event; do
        case "$event" in
            activewindow\>\>*)
                # Skip if physical keyboard is present
                [[ -f "$KB_STATE_FILE" ]] && continue

                # Parse class from "activewindow>>CLASS,TITLE"
                local class="${event#activewindow>>}"
                class="${class%%,*}"

                # Clear dismissed state when window changes
                if [[ "$class" != "$prev_class" ]]; then
                    rm -f "$OSK_DISMISSED_FILE"
                    prev_class="$class"
                fi

                # Don't re-show if user manually dismissed
                [[ -f "$OSK_DISMISSED_FILE" ]] && continue

                # Auto-show for terminals (they don't use text-input-v3).
                # For other apps, preserve current visibility — user can
                # toggle manually with Super+Shift+K.
                if is_terminal_class "$class"; then
                    osk_show
                fi
                ;;
        esac
    done
}

osk_daemon() {
    # Two-source monitor:
    #   1. udev — keyboard attach/detach (start/kill wvkbd)
    #   2. Hyprland IPC — active window focus (show wvkbd for terminals,
    #      let input-method-v2 handle text fields in other apps)

    local pidfile="${XDG_RUNTIME_DIR:-/tmp}/x1fold-osk-daemon.pid"

    # Prevent multiple daemon instances
    if [[ -f "$pidfile" ]] && kill -0 "$(cat "$pidfile")" 2>/dev/null; then
        echo "OSK daemon already running (pid $(cat "$pidfile"))" >&2
        exit 0
    fi
    echo $$ > "$pidfile"

    if ! command -v socat &>/dev/null; then
        echo "Error: socat is required for OSK daemon (sudo pacman -S socat)" >&2
        exit 1
    fi

    # Initial keyboard state
    if has_physical_keyboard; then
        touch "$KB_STATE_FILE"
        pkill -x wvkbd-mobintl 2>/dev/null || true
    else
        rm -f "$KB_STATE_FILE"
        ensure_wvkbd
    fi

    # Start keyboard presence monitor in background
    monitor_keyboard_presence &
    local udev_pid=$!
    trap "kill $udev_pid 2>/dev/null; rm -f '$KB_STATE_FILE' '$pidfile'" EXIT

    # Monitor active window in foreground
    monitor_active_window
}

case "${1:-toggle}" in
    show)    osk_show ;;
    hide)    osk_hide ;;
    toggle)  osk_toggle ;;
    daemon)  osk_daemon ;;
    *)
        echo "Usage: x1fold-osk [toggle|show|hide|daemon]" >&2
        exit 1
        ;;
esac
